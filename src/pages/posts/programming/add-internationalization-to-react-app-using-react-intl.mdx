---
title: Add Internationalization to a React App Using React Intl üåé
topic: programming
routename: add-internationalization-to-react-app-using-react-intl
description: Notes from Damon Bauer's Add Internationalization (i18n) to a React app using React Intl course on egghead.io.
postnum: 3
---

import Link from 'next/link'
import Image from 'next/image'

export const meta = {
  title: 'Add Internationalization to a React App Using React Intl üåé',
  description: "Notes from Damon Bauer's course on egghead.io",
  url:
    'https://parkerlandon.com/posts/programming/add-internationalization-to-react-app-using-react-intl',
  titleAppendSiteName: true,
  ogImage: {
    url:
      'https://adoring-jackson-1187ff.netlify.app/.netlify/functions/gen-opengraph-image?title=Add%20Internationalization%20to%20a%20React%20App%20Using%20React%20Intl&tags=react,enzyme,jest',
    width: 1200,
    height: 630,
  },
}

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/image.png"
  width="1024"
  height="480"
  layout="responsive"
/>

## üåü About

These notes go along with the _[Add Internationalization (i18n) to a React app using React Intl](https://egghead.io/courses/add-internationalization-i18n-to-a-react-app-using-react-intl)_ course from [Damon Bauer](https://egghead.io/instructors/damon-bauer) on [egghead.io](http://egghead.io/).

In this course, you can expect to

- Develop a React project with Create-React-App üî®
- Install and use react-intl in your project üåé
- Learn how react-intl simplifies internationalization with data-formatting tools üìù
- Centralize the content across your application into language specific message objects üí¨
- Write tests for components that include react-intl components with Enzyme and Jest üß™

The original notes can be found [here on my GitHub](https://github.com/ParkerGits/add-internationalization-to-react-app-using-react-intl-notes).

## üë©‚Äçüíª Code

Updated code for each lesson of this course can be found [here](https://github.com/ParkerGits/add-internationalization-to-react-app-using-react-intl-course-code).

Lesson code resides on branch with corresponding name.

## üìñ Table of Contents

1. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-install-and-configure-entry-point-of-react-intl">
     Install and Configure the Entry Point of react-intl
   </Link>

2. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-convert-a-hard-coded-string-using-react-intl-formattedmessage">
     Convert a Hard Coded String using react-intl FormattedMessage
   </Link>

3. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-render-content-with-placeholders-using-react-intl-formattedmessage">
     Render Content with Placeholders using react-intl FormattedMessage
   </Link>

4. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-render-content-with-markup-using-react-intl-formattedhtmlmessage">
     Render Content with Markup Using react-intl FormattedHTMLMessage
   </Link>

5. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-format-date-and-time-using-react-intl-formatteddate-and-formattedtime">
     Format Date and Time Using react-intl FormattedDate and FormattedTime
   </Link>

6. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-format-a-date-relative-to-the-current-date-using-react-intl-formattedrelative">
     Format a Date Relative to the Current Date Using react-intl
     FormattedRelative
   </Link>

7. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-format-numbers-with-separators-and-currency-symbols-using-react-intl-formattednumber">
     Format Numbers with Separators and Currency Symbols using react-intl
     FormattedNumber
   </Link>

8. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-render-content-based-on-a-number-using-react-intl-formattedmessage">
     Render Content Based on a Number using react-intl FormattedMessage
   </Link>

9. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl-use-a-react-intl-higher-order-component-to-format-messages-and-get-current-locale">
     Use a react-intl Higher Order Component to format messages and get current
     locale
   </Link>

10. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-write-tests-for-react-intl-output-using-enzyme-and-jest">
      Write tests for react-intl output using enzyme and Jest
    </Link>

11. <Link href="/posts/programming/add-internationalization-to-react-app-using-react-intl#-use-webpack-to-conditionally-include-an-intl-polyfill-for-older-browsers">
      Use Webpack to Conditionally Include an Intl Polyfill for Older Browsers
    </Link>

## üî® Install and Configure Entry Point of react-intl

### Starting your project with Create-React-App

Before the course begins, we will need to create our React project folder with Create-React-App.

In the terminal, navigate to the directory of your choice, and run the following commands:

To install the necessary files and create the necessary folders,

```bash
npx create-react-app my-app
```

To navigate to your new project folder,

```bash
cd my-app
```

To start your development server,

```bash
yarn start
```

Our next step is to install some dependencies, so you may now want to stop your development server with `Ctrl+C` now that we know our project works.

### Installing Dependencies

To add react-intl to our project, we run in the terminal

```bash
yarn add react-intl
```

### Creating our Messages file

We'll now create a file to store all our messages in our app.

In our **src** folder, we create a **messages.js** file, and within we'll export an object with keys that correspond to the languages that our app will support:

‚ö† Note: The course uses `'es-ES'` and `'fr-FR'`, but these codes aren't supported by Google Chrome's French and Spanish language settings, so these notes use `'es'` and `'fr'` instead.

### messages.js

```js
export default {
  'en-US': {},
  es: {},
  fr: {},
}
```

### Defining user Locale and using the IntlProvider component

We can now navigate to our entry-point file, **src/index.js**, and import from the **src/messages.js** file that we just created. We'll now import what we need from the react-intl package.

### Deprecation ‚ö†

As of writing these notes (7/28/2020), react-intl no longer comes with CLDR data, but instead relies on native Intl API. You can read more about these updates [here](https://formatjs.io/docs/react-intl/upgrade-guide-3x/#migrate-to-using-native-intl-apis).

For our sake, this just means that we no longer need to import `addLocaleData` and each language's locale file that we want to support.

The only import that we need to add now, along with our `messages`, is `IntlProvider`: a required component to use react-intl.

### index.js

```js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import * as serviceWorker from './serviceWorker';

// New Imports
import messages from `./messages`;
import { IntlProvider } from 'react-intl';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);
```

With everything imported, we now want to define the user's `locale`:

### index.js

```js
...

let locale = (navigator.languages && navigator.languages[0])
             || navigator.language
             || navigator.userLanguage
             || 'en-US';

ReactDOM.render(
  ...
);
```

Our `locale` variable first checks for `navigator.languages` and evaluates to `navigator.languages[0]` if that exists.

"The first value in the array is typically the preferred language of the user"

If `navigator.languages` isn't supported by the browser, `locale` evaluates to `navigator.language`. If that isn't supported by the browser, `locale` evaluates to `navigator.userlanguage`, and if that isn't supported by the browser, `locale` will finally evaluate to `en-US`.

Now that `IntlProvider` is imported, we'll wrap our `App` component with it.

### index.js

```js
...

let locale = (navigator.languages && navigator.languages[0])
             || navigator.language
             || navigator.userLanguage
             || 'en-US';

ReactDOM.render(
  <IntlProvider locale={locale} messages={messages[locale]}>
    <App />
  </IntlProvider>,
  document.getElementById('root')
);
```

We first pass in a `locale` prop and provide it with our `locale` variable, which tells react-intl to use the locale as defined by our variable.

Then, we tell our `IntlProvider` what messages to use by passing in a `messages` prop with value `messages[locale]`, as we want the messages associated with the user's defined `locale`.

### Resources üìñ

- [Create-React-App](https://reactjs.org/docs/create-a-new-react-app.html)
- [Migrate to using native Intl APIs - react-intl](https://formatjs.io/docs/react-intl/upgrade-guide-3x/#migrate-to-using-native-intl-apis)
- [ISO Language Codes](https://www.andiamo.co.uk/resources/iso-language-codes/)

## üí¨ Convert a Hard Coded String using react-intl FormattedMessage

### Adding Messages for each Language

In **src/messages.js**, we'll add some messages for each supported language.

### messages.js

```js
export default {
  'en-US': {
    detail: {
      toggle: 'Toggle',
      purchase: 'Purchase this book from:',
      reviewsHeading: 'Reviews',
    },
  },
  es: {
    detail: {
      toggle: 'Palanca',
      purchase: 'Compre este libro de:',
      reviewsHeading: 'Comentarios',
    },
  },
  fr: {
    detail: {
      toggle: 'Basculer',
      purchase: 'Achetez ce livre √† partir de:',
      reviewsHeading: 'Avis',
    },
  },
}
```

We've created nested objects under each language because it provides structure and readability, but react-intl **expects a completely flat object to be provided to its props**.

### Flattening our Messages

In order to use the nested structure, we need to use a `flattenMessages` utility. In **src**, we'll create a new file called **utils.js**, and we'll define our `flattenMessages` function inside.

### utils.js

```js
export function flattenMessages(nestedMessages, prefix = '') {
  return Object.keys(nestedMessages).reduce((messages, key) => {
    let value = nestedMessages[key]
    let prefixedKey = prefix ? `${prefix}.${key}` : key

    if (typeof value === 'string') {
      messages[prefixedKey] = value
    } else {
      Object.assign(messages, flattenMessages(value, prefixedKey))
    }

    return messages
  }, {})
}
```

The above function will take one of our nested key-value pairs, such as `toggle: 'Toggle'` within `detail`, and flatten it by producing the key-value pair `detail.toggle: 'Toggle'`. This allows us to use standard JSON notation with nested key-value pairs.

We now need to import our `flattenMessages` utility into our entry-point, **src/index.js**, and use it in our `messages` prop in order for react-intl to read `messages[locale]` as a flat object.

### index.js

```js
...

ReactDOM.render(
  <IntlProvider locale={locale} messages={flattenMessages(messages[locale])}>
    <App />
  </IntlProvider>,
  document.getElementById('root')
);
```

We can begin to translate our app now that our `messages` can be read by react-intl.

### Necessary Components, Styles, and Objects

To continue following along with the lesson, we need to some specific components, styles and JSON objects. All that is too much to gracefully paste here, so you can find the necessary code [under the _Necessary Components_ and _Other Files to Add/Edit_ headers here.](https://github.com/ParkerGits/add-internationalization-to-react-app-using-react-intl-notes/blob/master/notes/02-convert-a-hard-coded-string-using-react-intl-formatted-message.md#necessary-components-)

### Displaying our Messages with FormattedMessage

Start your development server in the terminal,

```bash
yarn start
```

And navigate to `localhost:3000` to see our project. If there are no errors, we should see the following:

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/02-convert-a-hard-coded-string-using-react-intl-formatted-message-homepage.png"
  width="1200"
  height="630"
  layout="responsive"
/>

Click on one of the books to view information about that book.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/02-convert-a-hard-coded-string-using-react-intl-formatted-message-book-information.png"
  width="1200"
  height="630"
  layout="responsive"
/>

Our goal now is to internationalize the "Read More" text by having it display from our `messages`.

To do this, we'll first navigate to **src/components/BookDetail.js**, and import `FormattedMessage` from react-intl.

Next, we'll navigate to our "Read More" text in the component and replace it with a `<FormattedMessage />` component. In this component, we'll pass in an `id` prop that directly correlates to the message we want to use within `messages.js`. In this case we'll assign `detail.toggle` to `id`.

### BookDetail.js

```js
import React from 'react';
// New Import
import { FormattedMessage } from 'react-intl'
import {meanBy, round, sortBy} from 'lodash';

import books from '../books.json';

...

<label className="BookDetail-descriptionToggle" htmlFor="toggle">
    <FormattedMessage id="detail.toggle" />
</label>
...
```

Saving and returning to our development server, we should see our change in place:

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/02-convert-a-hard-coded-string-using-react-intl-formatted-message-toggle-button.png"
  width="1200"
  height="500"
  layout="responsive"
/>

We'll now also replace the "Purchase this book from" and "Reviews" headers with `FormattedMessage` components. The former will display `detail.purchase` and the latter will display `detail.reviewsHeading`.

### BookDetail.js

```js
...

<h3 className="BookDetail-merchantHeading">
    <FormattedMessage id="detail.purchase"/>
</h3>
...

<h2>
    <FormattedMessage id="detail.reviewsHeading"/>
</h2>
...
```

When we save our changes, we can view our webpage in different languages to see our translated messages displayed.

### English

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/02-convert-a-hard-coded-string-using-react-intl-formatted-message-english-translation.png"
  width="1200"
  height="600"
  layout="responsive"
/>

### Spanish

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/02-convert-a-hard-coded-string-using-react-intl-formatted-message-spanish-translation.png"
  width="1200"
  height="600"
  layout="responsive"
/>

### French

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/02-convert-a-hard-coded-string-using-react-intl-formatted-message-french-translation.png"
  width="1200"
  height="600"
  layout="responsive"
/>

### Resources üìñ

- [FormattedMessage - react-intl](https://formatjs.io/docs/react-intl/components/#formattedmessage)

## üîÆ Render Content with Placeholders using react-intl FormattedMessage

### Using Placeholders in our Messages

We'll start by adding some new messages to our **src/messages.js** file.

### messages.js

```js
export default {
  'en-US': {
    detail: {
      author: 'by {author}',
      toggle: 'Toggle',
      purchase: 'Purchase this book from:',
      reviewsHeading: 'Reviews',
      averageRating: 'Average Rating: {avg}',
      userRating: '{name} rated it: {rating} out of 5',
    },
  },
  es: {
    detail: {
      author: 'de {author}',
      toggle: 'Palanca',
      purchase: 'Compre este libro de:',
      reviewsHeading: 'Comentarios',
      averageRating: 'Puntuaci√≥n media: {avg}',
      userRating: '{name} clasificado: {rating} de 5',
    },
  },
  fr: {
    detail: {
      author: 'par {author}',
      toggle: 'Basculer',
      purchase: 'Achetez ce livre √† partir de:',
      reviewsHeading: 'Avis',
      averageRating: 'Note moyenne: {avg}',
      userRating: "{name} L'a not√©: {rating} sur 5",
    },
  },
}
```

Above, we've assigned strings containing placeholders to our `averageRating`, `author`, and `userRating` properties. We can provide our components with content to replace these placeholders when they're rendered.

We can now navigate to **src/components/BookDetail.js** and replace our `book.author` heading with a `FormattedMessage` component in which we'll pass two props.

- `id="detail.author"` to specify the `author` message,
- `values={{author: book.author}}` so that the `{author}` placeholder is rendered as `book.author`.

### BookDetail.js

```js
...
<h3>
    <FormattedMessage id="detail.author" values={{author: book.author}} />
</h3>
...
```

When we save our changes and start our development server,

```bash
yarn start
```

We should be able to navigate to a book in our development server and see that the author heading is rendered in the language set by our browser, and the `{author}` placeholder is substituted by `book.author`.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/03-render-content-with-placeholders-using-react-intl-formatted-message-author-translate.png"
  width="1200"
  height="125"
  layout="responsive"
/>

Next, we'll replace our "Average Rating" header.

In order to improve readability, we'll start by creating a variable that evaluates to the average rating of the book, then we'll plug that into the header.

```js
...
const BookDetail = ({match}) => {
  const book = books.find(book => book.id === parseInt(match.params.bookId, 10));
  const sortedReviews = sortBy(book.reviews, 'date').reverse();
  // Average Rating Variable
  const avgRating = round(meanBy(book.reviews, (r) => r.rating), 2)

  ...
```

Now we'll replace the former header with a `<FormattedMessage />` that displays `detail.averageRating` and evaluates the `{avg}` placeholder to our `avgRating` variable.

### BookDetail.js

```js
...
<h3>
    <FormattedMessage id="detail.averageRating" values={{avg: avgRating}} /> ({book.reviews.length} Reviews)
</h3>

...
```

We should now be able to navigate to our development server and see our Average Rating header display our `detail.averageRating` message with `avgRating` substituting the placeholder.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/03-render-content-with-placeholders-using-react-intl-formatted-message-average-rating-translate.png"
  width="1200"
  height="80"
  layout="responsive"
/>

The final header that we'll be refactoring with a `<FormattedMessage />` component is the reviewer's name and rating.

Into `<FormattedMessage />`, we'll pass in two props.

- `id="detail.userRating"` to specify the `userRating` message,

For our second prop: if you look at the `BookDetail` user review header, you'll see that the name of the reviewer is wrapped in a `<strong>` tag. We can actually pass markdown into our `values` prop, and react-intl will render it correctly. So for our placeholders to be rendered as we want, our second prop should look like `values={{name: <strong>{review.name}</strong>, rating: review.rating}}/>`.

### BookDetail.js

```jsx
<p>
  <FormattedMessage
    id="detail.userRating"
    values={{name: <strong>{review.name}</strong>, rating: review.rating}}
  />
  <br />
  {new Date(review.date).toLocaleDateString()}
</p>
```

If we head to our development server, we should see our placeholders have rendered correctly. This includes both the rendering of the reviewer's name in bold and the rating that the reviewer gave. Furthermore, our message should change depending on the language of the user's browser.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/03-render-content-with-placeholders-using-react-intl-formatted-message-review-translate.png"
  width="1200"
  height="70"
  layout="responsive"
/>

### Resources üìñ

- [FormattedMessage - react-intl](https://formatjs.io/docs/react-intl/components/#formattedmessage)

## üé• Render Content with Markup Using react-intl FormattedHTMLMessage

### Displaying Messages with Markdown Elements

In our **src/messages.js** file, we're going to add `window` messages.

### messages.js

```js
export default {
  'en-US': {
    detail: {
      author: 'by {author}',
      toggle: 'Toggle',
      purchase: 'Purchase this book from:',
      window:
        '<small><em>All {numMerchants} links open in a new window.</em></small>',
      reviewsHeading: 'Reviews',
      averageRating: 'Average Rating: {avg}',
      userRating: '{name} rated it: {rating} out of 5',
    },
  },
  es: {
    detail: {
      author: 'de {author}',
      toggle: 'Palanca',
      purchase: 'Compre este libro de:',
      window:
        '<small><em>Los {numMerchants} enlaces se abren en una nueva ventana.</em></small>',
      reviewsHeading: 'Comentarios',
      averageRating: 'Puntuaci√≥n media: {avg}',
      userRating: '{name} clasificado: {rating} de 5',
    },
  },
  fr: {
    detail: {
      author: 'par {author}',
      toggle: 'Basculer',
      purchase: 'Achetez ce livre √† partir de:',
      window:
        "<small><em>Les {numMerchants} liens s'ouvrent dans une nouvelle fen√™tre.</em></small>",
      reviewsHeading: 'Avis',
      averageRating: 'Note moyenne: {avg}',
      userRating: "{name} L'a not√©: {rating} sur 5",
    },
  },
}
```

As you can see, our `window` message contains markdown.

### Deprecation ‚ö†

As of react-intl v4, the `FormattedHTMLMessage` component has been removed. This is the component that the instructor of the course uses to render the markdown correctly.

Now, to render the markdown in our message correctly, we can use a `FormattedMessage` component and resolve the markdown tags in the `values` prop, as is done in the example below.

### BookDetail.js

```jsx
...
<div className="BookDetail-merchants">
    {book.merchants.map((merchant) => (
        <a href={merchant.link} className="Merchant" key={merchant.name} target="_blank">
        <img src={merchant.icon} width="32" height="32" alt={merchant.name}/>
        <strong>{merchant.name}</strong>
        <p>{merchant.price}</p>
        </a>
    ))}
</div>
// New Message
<FormattedMessage id="detail.window" values={{numMerchants: book.merchants.length, small: chunks => <small>{chunks}</small>, em: chunks => <em>{chunks}</em>}} />

...
```

If we start our development server,

```bash
yarn start
```

And navigate to our localhost port, we should see our new `FormattedMessage` component displaying our message with correctly rendered markdown.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/04-render-content-with-markup-using-react-intl-formatted-html-message-markdown-render.png"
  width="1200"
  height="550"
  layout="responsive"
/>

### Resources üìñ

- [FormattedMessage Rich Text Formatting - react-intl](https://formatjs.io/docs/react-intl/components#rich-text-formatting)

## ‚è∞ Format Date and Time Using react-intl FormattedDate and FormattedTime

### Using the FormattedDate Component

In our **src/components/BookDetail.js**, we will import `FormattedDate` and `FormattedTime` components from react-intl.

### BookDetail.js

```js
import {FormattedMessage, FormattedDate, FormattedTime} from 'react-intl'
```

If we navigate to **src/books.json**, we can see that the `date` property is one long number

### books.json

```json
"date": 1491111687199,
```

"This is an instance of a date represented in a Unix timestamp in milliseconds."

with the newly imported `FormattedDate` component and our timestamps, we can refactor our `BookDetail` component so that the dates are formatted according to the user's language.

We'll pass the timestamp into a `Date` object, which we will then pass into a `FormattedDate` component through a `value` prop. Then, we'll set the `year`, `month`, and `day` props to `"numeric"` for now.

### BookDetail.js

```jsx
<div className="Review-meta">
  <img src={review.avatar} alt="Avatar" />
  <p>
    <FormattedMessage
      id="detail.userRating"
      values={{name: <strong>{review.name}</strong>, rating: review.rating}}
    />
    <br />
    <FormattedDate
      value={new Date(review.date)}
      year="numeric"
      month="numeric"
      day="numeric"
    />
    <br />
  </p>
</div>
```

If we now start our development server,

```bash
yarn start
```

And navigate to our localhost, we should see our dates render correctly.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/05-format-date-and-time-using-react-intl-formatted-date-and-formatted-time-numeric-date.png"
  width="1200"
  height="300"
  layout="responsive"
/>

To change the date format, we can change the props of the `FormattedDate` component:

### BookDetail.js

```jsx
<FormattedDate
    value={new Date(review.date)}
    year="numeric"
    month="long"
    day="numeric" /><br />
```

Navigating back to our page, we should now see our date has changed format.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/05-format-date-and-time-using-react-intl-formatted-date-and-formatted-time-long-month-date.png"
  width="1200"
  height="300"
  layout="responsive"
/>

For this app, we want our `year`, `month`, and `date` props to be `"2-digit"`, so we'll change that now.

### BookDetail.js

```jsx
<FormattedDate
    value={new Date(review.date)}
    year="2-digit"
    month="2-digit"
    day="2-digit" /><br />
```

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/05-format-date-and-time-using-react-intl-formatted-date-and-formatted-time-2-digit-date.png"
  width="1200"
  height="325"
  layout="responsive"
/>

### Using the FormattedTime Component

Our `review.time` property was a timestamp that measured down to the millisecond, so we can render all of that time information in a `FormattedTime` component.

We'll comment out our `FormattedDate` component and pass the same props into a `FormattedTime` component.

### BookDetail.js

```jsx
{/* <FormattedDate
    value={new Date(review.date)}
    year="2-digit"
    month="2-digit"
    day="2-digit" /><br /> */}

<FormattedTime
    value={new Date(review.date)}
    year="2-digit"
    month="2-digit"
    day="2-digit" /><br />
```

Navigating back to our page, we should see now that the displayed date also includes a formatted time.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/05-format-date-and-time-using-react-intl-formatted-date-and-formatted-time-formatted-time.png"
  width="1200"
  height="325"
  layout="responsive"
/>

### Resources üìñ

- [FormattedDate Component - react-intl](https://formatjs.io/docs/react-intl/components/#formatteddate)
- [FormattedTime Component - react-intl](https://formatjs.io/docs/react-intl/components/#formattedtime)

## üìÖ Format a Date Relative to the Current Date Using react-intl FormattedRelative

### Using the FormattedRelativeTime Component

### Deprecation ‚ö†

As of react-intl v3, `FormattedRelative` has been renamed to `FormattedRelativeTime`, the value prop accepts a delta instead of a `Date`, `updateInterval` has been changed to `updateIntervalInSeconds`, and the `style` prop has been changed.

We'll start by importing `FormattedRelativeTime` from react-intl in **src/components/BookDetail.js**

### BookDetail.js

```js
import {
  FormattedMessage,
  FormattedDate,
  FormattedTime,
  FormattedRelativeTime,
} from 'react-intl'
```

Now we can go into our `BookDetail` component and add a `FormattedRelativeTime` component after our `FormattedTime` component from the previous lesson.

**Note**: The `FormattedRelativeTime` component now expects a delta (difference between times) passed into its `value` prop instead of a `Date`. Furthermore, we must also define the units of the delta with a `unit` prop.

### BookDetail.js

```jsx
...
<FormattedTime
value={new Date(review.date)}
year="2-digit"
month="2-digit"
day="2-digit" /><br />

// New Component
<FormattedRelativeTime
  value={-1 * Math.floor((Date.now() - review.date)/((1000*60*60*24)))}
  unit="days"/><br />

...
```

To the `value` prop, I pass in a function which calculates the difference between today's date and the date of the review, converts that number (milliseconds) to days, then multiplies that number by `-1` because the review occurred prior to today's date.

Furthermore, because my value is in days, I pass `"days"` into the `unit` prop.

Now if we start our development server,

```bash
yarn start
```

We can navigate to our localhost port in the browser and see that the relative date is formatted as expected:

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/06-format-a-date-relative-to-the-current-date-using-react-intl-formatted-relative-relative-date-days.png"
  width="1200"
  height="325"
  layout="responsive"
/>

By default, this component will automatically re-render at a maximum of every 10 seconds. We can specify our update interval with the `updateIntervalInSeconds` prop.

To use this prop, we need to make sure our `unit` prop is assigned a unit no longer than an hour. Then, we can simply pass in the number of seconds we want between update intervals.

### BookDetail.js

```jsx
<FormattedRelativeTime
  value={0}
  unit="second"
  updateIntervalInSeconds="1"/><br />
```

We can return to our site and see that our displayed relative time is indeed updating every 1 second.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/06-format-a-date-relative-to-the-current-date-using-react-intl-formatted-relative-update-interval.gif"
  width="1200"
  height="325"
  layout="responsive"
/>

The `updateIntervalInSeconds` prop could severely slow down your site in production, as it is re-rendering the component at every interval. This can be especially unwanted if the component re-renders every second, but the relative time isn't changing because it's beyond displaying individual seconds.

Finally, the instructor shows us how we can set our component to always display a number. For this, the `style` prop is used; however, this prop has been changed.

Now, if you want your component to always render a number, the `numeric="always"` prop should be passed in.

Furthermore, the `style` prop now accepts either `long`, `short`, or `narrow`. The `long` setting displays the unit in it's full form, while the `short` and `narrow` settings display the shorthand form of the unit (sec., min., hr., yr.).

### BookDetail.js

```jsx
<FormattedRelativeTime
  value={-1 * Math.floor((Date.now() - review.date)/((1000*60*60*24)))}
  unit="year"
  style="short"
  numeric="always"/><br />
```

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/06-format-a-date-relative-to-the-current-date-using-react-intl-formatted-relative-short.png"
  width="1200"
  height="400"
  layout="responsive"
/>

### Resources üìñ

- [FormattedRelativeTime - react-intl](https://formatjs.io/docs/react-intl/components/#formattedrelativetime)

## üí∏ Format Numbers with Separators and Currency Symbols using react-intl FormattedNumber

### Using the FormattedNumber Component

We'll start by importing `FormattedNumber` from react-intl in **src/components/BookDetail.js**

### BookDetail.js

```jsx
import {
  FormattedMessage,
  FormattedDate,
  FormattedTime,
  FormattedRelativeTime,
  FormattedNumber,
} from 'react-intl'
```

In this lesson, the instructor has gone ahead and changed the **books.json** file so that the `price` key of each book is an object containing a price for each supported locale. Therefore, we must also change our **src/books.json** to match the instructor's. This, again, is too much to paste here, so you can find the code for `books.json` [here](https://github.com/ParkerGits/add-internationalization-to-react-app-using-react-intl-notes/blob/master/notes/07-format-numbers-with-separators-and-currency-symbols-using-react-intl-formatted-number.md#using-the-formattednumber-component-).

Now, in our `BookDetail` component, we're going to use the same function to grab the user's locale that we used in our **src/index.js**.

### BookDetail.js

```jsx
const BookDetail = ({match}) => {
  const book = books.find(book => book.id === parseInt(match.params.bookId, 10));
  const sortedReviews = sortBy(book.reviews, 'date').reverse();
  const avgRating = round(meanBy(book.reviews, (r) => r.rating), 2)

  let locale = (navigator.languages && navigator.languages[0])
             || navigator.language
             || navigator.userLanguage
             || 'en-US';
...
```

We can now get rid of the `merchant.price` text in this component and replace it with a `FormattedNumber` component. Here we're going to pass in a `value` prop and provide it with `merchant.price[locale]` in order to display the correct price based on the user locale.

```jsx
...

<p>
  <FormattedNumber value={merchant.price[locale]} />
</p>

...
```

We can also pass in a `style` prop with value `currency` and a `currencyDisplay` prop with value `symbol` to display the correct currency symbol on our page. Finally we'll pass in a `currency` prop and have it conditionally be provided `'USD'` if `locale` is `'en-US'`, or `'EUR'` otherwise.

```jsx
<FormattedNumber
  value={merchant.price[intl.locale]}
  style="currency"
  currencyDisplay="symbol"
  currency={intl.locale === 'en-US' ? 'USD' : 'EUR'}
/>
```

We can start our development server,

```bash
yarn start
```

And navigate to the localhost port to see that our price is displayed with the correct currency symbol for the locale.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/07-format-numbers-with-separators-and-currency-symbols-using-react-intl-formatted-number-currency.png"
  width="1200"
  height="150"
  layout="responsive"
/>

### Resources üìñ

- [FormattedNumber - react-intl](https://formatjs.io/docs/react-intl/components/#formattednumber)

## üî¢ Render Content Based on a Number using react-intl FormattedMessage

### Making our Messages More Friendly

Currently, no matter how many reviews a book has, our app always renders the number of reviews, then the word reviews.

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/08-render-content-based-on-a-number-using-react-intl-formatted-message-reviews-before.png"
  width="1200"
  height="300"
  layout="responsive"
/>

We can make this more friendly by first changing our `avgRating` variable in **src/components/BookDetail.js**. Let's have the variable evaluate to what it is now when `book.reviews.length` is true (when there are book reviews), and have it evaluate to 0 when `book.reviews.length` is false (there are no book reviews).

### BookDetail.js

```js
const avgRating = book.reviews.length
  ? round(
      meanBy(book.reviews, (r) => r.rating),
      2,
    )
  : 0
```

Now, let's head down to our average rating `FormattedMessage` component and pass another object into `values` with key `count` and value `book.reviews.length`. Furthermore, we'll delete the text in the parenthesis that follows it.

### BookDetail.js

```js
<h3>
  <FormattedMessage
    id="detail.averageRating"
    values={{avg: avgRating, count: book.reviews.length}}
  />
</h3>
```

Back in our **src/messages.js**, we'll put our new `count` value with a placeholder in the `averageRating` message. We're also going to include the keyword `plural`, which will allow us to conditionally render messages based on the value of `count`.

### messages.js

```js
averageRating: 'Average Rating: {avg} ({count, plural, =0 {No Reviews Yet!} one {# Review} other {# Reviews}})',
```

To the right of the comma next to `plural`, we're conditionally rendering messages based on the value of `count`.

- `=0 {No Reviews Yet!}` tells react-intl to display "No Reviews Yet!" when `count` is 0
- `one {# Review}` tells react-intl to display a message when `count` is 1. The `#` symbol is a placeholder for the value of `count`, so in this case the message displayed would be "1 Review"
- `other {# Reviews}` tells react-intl to display a message when `count` is neither of the previously described conditions (0 or 1). `#` is a placeholder for the value of `count`, so the message will be "{value of count} Reviews".

Now we should add this functionality to the other languages:

### messages.js

```js
export default {
  'en-US': {
    detail: {
      author: 'by {author}',
      toggle: 'Toggle',
      purchase: 'Purchase this book from:',
      window:
        '<small><em>All {numMerchants} links open in a new window.</em></small>',
      reviewsHeading: 'Reviews',
      averageRating:
        'Average Rating: {avg} ({count, plural, =0 {No Reviews Yet!} one {# Review} other {# Reviews}})',
      userRating: '{name} rated it: {rating} out of 5',
    },
  },
  es: {
    detail: {
      author: 'de {author}',
      toggle: 'Palanca',
      purchase: 'Compre este libro de:',
      window:
        '<small><em>Los {numMerchants} enlaces se abren en una nueva ventana.</em></small>',
      reviewsHeading: 'Comentarios',
      averageRating:
        'Puntuaci√≥n media: {avg} ({count, plural, =0 {No hay comentarios todav√≠a!} one {# Cr√≠tica} other {# Cr√≠ticas}})',
      userRating: '{name} clasificado: {rating} de 5',
    },
  },
  fr: {
    detail: {
      author: 'par {author}',
      toggle: 'Basculer',
      purchase: 'Achetez ce livre √† partir de:',
      window:
        "<small><em>Les {numMerchants} liens s'ouvrent dans une nouvelle fen√™tre.</em></small>",
      reviewsHeading: 'Avis',
      averageRating:
        'Note moyenne: {avg} ({count, plural, =0 {Pas encore de commentaires!} one {# La revue} other {# Avis}})',
      userRating: "{name} L'a not√©: {rating} sur 5",
    },
  },
}
```

Now if we start our development server,

```bash
yarn start
```

And navigate to our localhost port, we should see that our average rating message is properly displayed for any number of reviews on any supported language.

### Many Reviews, Different Languages

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/08-render-content-based-on-a-number-using-react-intl-formatted-message-conditional-reviews-many.png"
  width="1200"
  height="650"
  layout="responsive"
/>

### No Reviews

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/08-render-content-based-on-a-number-using-react-intl-formatted-message-zero-reviews.png"
  width="1200"
  height="300"
  layout="responsive"
/>

### Resources üìñ

- [FormattedMessage Plural Format - react-intl](https://formatjs.io/docs/icu-syntax#plural-format)

## üå¥ Use a react-intl Higher Order Component to format messages and get current locale

### Accepting User Reviews

At the bottom of **src/components/BookDetail.js**, let's add a `textarea` element where users can add their own review. In this `textarea` element, we want a `placeholder` attribute to tell the user what the `textarea` is for. However, we want this `placeholder` value to be in the user's language.

### BookDetail.js

```jsx
      ...
      </div>

      <textarea placeholder=""></textarea>

    </div>
  )
}

export default BookDetail;
```

We'll first navigate to our **src/messages.js** file and add an `inputPlaceholder` message for each language.

### messages.js

```js
export default {
  'en-US': {
    detail: {
      ...
      inputPlaceholder: 'What did you think? Enter your review here.'
    }
  },
  'es': {
    detail: {
      ...
      inputPlaceholder: '¬øQue piensas? Introduzca su comentario aqu√≠.'
    }
  },
  'fr': {
    detail: {
      ...
      inputPlaceholder: 'Qu\'as-tu pens√©? Entrez votre avis ici.'
    }
  }
}
```

Next, we'll navigate back to our `textarea` element in **src/components/BookDetail.js**.

You may think to pass a `FormattedMessage` component with `id="details.inputPlaceholder"` to our `textarea` `placeholder` attribute. However, if we do that,

```jsx
<textarea placeholder={<FormattedMessage id="detail.inputPlaceholder" />} />
```

And start our development server,

```bash
yarn start
```

Our `textarea` wil be rendered like this:

<Image
  src="/images/posts/add-internationalization-to-react-app-using-react-intl/09-use-a-react-intl-higher-order-component-to-format-messages-and-get-current-locale-object-placeholder.png"
  width="1200"
  height="300"
  layout="responsive"
/>

The `FormattedMessage` component doesn't actually render like we'd expect when it's inside of the `placeholder` attribute.

### Using the injectIntl Higher Order Component

We can fix this issue with the react-intl `injectIntl` higher order component.

We'll start by importing `injectIntl` from react-intl in our `BookDetail` component.

### BookDetail.js

```js
import {
  FormattedMessage,
  FormattedDate,
  FormattedTime,
  FormattedRelativeTime,
  FormattedNumber,
  injectIntl,
} from 'react-intl'
```

Next, we'll have our `BookDetail` component accept an `intl` argument which will be passed in by the `IntlProvider` parent component.

### BookDetail.js

```js
const BookDetail = ({match, intl}) => {
    ...
}
```

Now we can provide our `placeholder` attribute with the value `intl.formatMessage({id: 'detail.inputPlaceholder'})`

### BookDetail.js

```jsx
<textarea
  placeholder={intl.formatMessage({id: 'detail.inputPlaceholder'})}
></textarea>
```

"The intl `formatMessage()` method is actually the underlying API that the `FormattedMessage` component uses, but we bypass the React component creation step and just get the string at `detail.inputPlaceholder` in the messages file."

Our final step is to wrap the `BookDetail` export in an `injectIntl` higher order component.

### BookDetail.js

```js
export default injectIntl(BookDetail)
```

### The intl Prop

With the `intl` prop passed into our `BookDetail` component, we can access the user's locale without the navigator lookup in the `BookDetail` component because the `locale` variable is already set up and passed into `IntlProvider` in **src/index.js**.

### index.js

```js
let locale =
  (navigator.languages && navigator.languages[0]) ||
  navigator.language ||
  navigator.userLanguage ||
  'en-US'

ReactDOM.render(
  <IntlProvider locale={locale} messages={flattenMessages(messages[locale])}>
    <App />
  </IntlProvider>,
  document.getElementById('root'),
)
```

Therefore, we can remove the `locale` variable from our `BookDetail` component, and access it instead with `intl.locale`.

### BookDetail.js

```jsx
const BookDetail = ({match, intl}) => {
  const book = books.find(book => book.id === parseInt(match.params.bookId, 10));
  const sortedReviews = sortBy(book.reviews, 'date').reverse();
  const avgRating = book.reviews.length ? round(meanBy(book.reviews, (r) => r.rating), 2) : 0;

  return (
    ...
    <FormattedNumber
        value={merchant.price[intl.locale]}
        style="currency"
        currencyDisplay="symbol"
        currency={intl.locale === 'en-US' ? 'USD' : 'EUR'}/>
    ...
  )
}

```

We should now be able to save our changes and view our site to see that it looks no different.

### Resources

- [Injection API - react-intl](https://formatjs.io/docs/react-intl/api#injection-api)

## üî¨ Write tests for react-intl output using enzyme and Jest

### Adding Dependencies

We're gonna need to install some dependencies for this lesson. In the terminal, at your project directory, run

```bash
yarn add enzyme enzyme-to-json react-addons-test-utils
```

We'll also need to add some test helper utilities. In your **src** folder, create a file called **intl-enzyme.js** and add the following code within:

### Deprecation ‚ö†

As of react-intl v3, `getChildContext()` is deprecated, so the helper function that the instructor uses will no longer work. Provided below is a different helper function that can be implemented just the same.

### intl-enzyme.js

```js
/**
 * Components using the react-intl module require access to the intl context.
 * This is not available when mounting single components in Enzyme.
 * These helper functions aim to address that and wrap a valid,
 * English-locale intl context around them.
 */

import React from 'react'
import {IntlProvider} from 'react-intl'
import {mount, shallow} from 'enzyme'
import {flattenMessages} from './utils'
// You can pass your messages to the IntlProvider. Optional: remove if unneeded.
import messages from './messages'
const defaultLocale = 'en-US'
const locale = defaultLocale
const flattenedMessages = flattenMessages(messages[locale])

export function mountWithIntl(node) {
  return mount(node, {
    wrappingComponent: IntlProvider,
    wrappingComponentProps: {
      locale,
      defaultLocale,
      flattenedMessages,
    },
  })
}

export function shallowWithIntl(node) {
  return shallow(node, {
    wrappingComponent: IntlProvider,
    wrappingComponentProps: {
      locale,
      defaultLocale,
      flattenedMessages,
    },
  })
}
```

"What this helper will do is wrap the component being tested with all of the correct parent components, contexts, and props required by react-intl."

This helper also allows us to use Enzyme's shallow rendering or full-mount rendering.

We can now begin writing tests with our dependencies installed and our test helper utilities added.

Navigate to **src/components** and create a new folder called \***\*tests\*\***. Within this folder, create a new file called **BookDetail.test.js** to house all of our tests for the `BookDetail` component.

Inside of **BookDetail.test.js**, we're going to import from React, enzyme-to-json, **BookDetail.js**, and our test helper utilities.

### BookDetail.test.js

```js
import React from 'react'
import {mountWithIntl, shallowWithIntl} from '../../intl-enzyme'
import toJson from 'enzyme-to-json'

import BookDetail from '../BookDetail'
```

### Deprecation ‚ö†

As of React-16, Enzyme requires an adapter to run tests. Start by adding enzyme-adapter-react-16:

```bash
yarn add enzyme-adapter-react-16
```

Next, in **BookDetail.test.js**, we'll configure the adapter:

### BookDetail.test.js

```js
import React from 'react'
import {mountWithIntl, shallowWithIntl} from '../../intl-enzyme'
import toJson from 'enzyme-to-json'

import BookDetail from '../BookDetail'

// Configure enzyme

import {configure} from 'enzyme'
import Adapter from 'enzyme-adapter-react-16'

configure({adapter: new Adapter()})
```

Now we should be all good to get started writing tests!

### Writing Assertions and Testing with Enzyme and Jest

We're going to initialize a `wrapper` variable to hold the rendered component in each test assertion.

### BookDetail.test.js

```js
let wrapper = null
```

Now we can write our first test assertion. First we create a `describe` block for our `BookDetail` component, then we'll assert that our component renders intended markup.

### BookDetail.test.js

```js
describe('BookDetail', () => {
  it('renders expected markup', () => {

  });
```

Within our `it` assertion, we provide our `wrapper` with an instance of our `BookDetail` component wrapped by `mountWithIntl`: `mountWithIntl(<BookDetail />)`.

### BookDetail.test.js

```js
describe('BookDetail', () => {
  it('renders expected markup', () => {
    wrapper = mountWithIntl(<BookDetail />);

  });
```

Within our `BookDetail` component, we want to provide the `match` prop from react-router-dom and pass in `{params: {bookId: 1}}` to specify that we want to test our component with the first book's information.

### BookDetail.test.js

```js
describe('BookDetail', () => {
  it('renders expected markup', () => {
    wrapper = mountWithIntl(<BookDetail match={{params: {bookId: 1}}}/>);
  });
```

Finally, we'll `expect` that `toJson(wrapper)` matches a snapshot (`toMatchSnapshot()`).

### BookDetail.test.js

```js
describe('BookDetail', () => {
  it('renders expected markup', () => {
    wrapper = mountWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
    expect(toJson(wrapper)).toMatchSnapshot()
  })
})
```

We can run our test by heading to the terminal and running,

```bash
yarn test
```

"That's it. We've got our first test. However, there's one problem with this test. Jest's docs correctly say that tests should be deterministic, meaning that running the same test multiple times on a component that has not changed should produce the same result."

The problem that the instructor is referring to above involves our `FormattedRelativeTime` component. Recall that `FormattedRelativeTime` renders the number of _days_ since a review was written. Because the rendered component is different from one day to the next, the snapshot test created today will fail tomorrow.

To fix this issue, we can "mock" `Date.now()` to return a constant timestamp. This way, no matter what day we run our test on, `Date.now()` is the same, so our rendered `FormattedRelativeTime` component doesn't change from day to day.

In our `BookDetail.test.js`, we can redefine `Date.now` to be a mock Jest function that returns a static timestamp:

### BookDetail.test.js

```js
import React from 'react'
import {mountWithIntl, shallowWithIntl} from '../../intl-enzyme'
import toJson from 'enzyme-to-json'

import BookDetail from '../BookDetail'

import {configure} from 'enzyme'
import Adapter from 'enzyme-adapter-react-16'

configure({adapter: new Adapter()})

Date.now = jest.fn(() => 1491111687199)

let wrapper = null

describe('BookDetail', () => {
  it('renders expected markup', () => {
    wrapper = mountWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
    expect(toJson(wrapper)).toMatchSnapshot()
  })
})
```

We can now run our test again, and we should see that it fails now that our `Date.now()` value is different. We can update our snapshot by pressing 'u' in the terminal, and now our test should pass.

"Now that we've seen a snapshot, let's take a look at using Enzyme to assert specific things with regards to react-intl components."

We're going to set up a nested `describe` block for `'intl messages'`, and within we're going to define a function to run before each test runs with `beforeEach()`.

### BookDetail.test.js

```js
describe('BookDetail', () => {
  it('renders expected markup', () => {
    wrapper = mountWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
    expect(toJson(wrapper)).toMatchSnapshot()
  })
  describe('intl messages', () => {
    beforeEach(() => {})
  })
})
```

Within `beforeEach()` we're going to define our wrapper. We'll pass in `shallowWithIntl(<BookDetail match={{params: { bookId: 1}}}>)`.

"Since our component is wrapped with the injectIntl higher-order component, calling `shallowWithIntl` will just provide the instance of `Intl` instead of our `BookDetail` component."

### Deprecation ‚ö†

In the lesson, the instructor, to fix this issue, calls `.first()` on `shallowWithIntl()` to get the first child of the component, then calls `.shallow()` on that. However, I've found that this does not actually provide us with the `wrapper` we want. If `shallowWithIntl(...).first().shallow()` doesn't work for you, I've provided an alternative that works for me below.

### BookDetail.test.js

```js
describe('BookDetail', () => {
  it('renders expected markup', () => {
    wrapper = mountWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
    expect(toJson(wrapper)).toMatchSnapshot()
  })
  describe('intl messages', () => {
    beforeEach(() => {
      wrapper = shallowWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
        .shallow()
        .shallow()
    })
  })
})
```

Now we can add an `it` block to define an assertion, and within it we'll `expect` to find one `{id: detail.purchase}` object.

### BookDetail.test.js

```js
describe('BookDetail', () => {
  it('renders expected markup', () => {
    wrapper = mountWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
    expect(toJson(wrapper)).toMatchSnapshot()
  })
  describe('intl messages', () => {
    beforeEach(() => {
      wrapper = shallowWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
        .shallow()
        .shallow()
    })
    it('renders a single "purchase" message', () => {
      expect(wrapper.find({id: 'detail.purchase'})).toHaveLength(1)
    })
  })
})
```

We can now run this test, again with `yarn test` in the terminal, and it should pass.

Finally, we can test that our our component `'passes number of merchants to "new window" message'` with another `it` block. This time, we'll `expect` the element with `id: 'detail.window'` to have a `values` prop of `numMerchants: 3`.

### BookDetail.test.js

```js
describe('BookDetail', () => {
  it('renders expected markup', () => {
    wrapper = mountWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
    expect(toJson(wrapper)).toMatchSnapshot()
  })

  describe('intl messages', () => {
    beforeEach(() => {
      wrapper = shallowWithIntl(<BookDetail match={{params: {bookId: 1}}} />)
        .shallow()
        .shallow()
    })

    it('renders a single "purchase" message', () => {
      expect(wrapper.find({id: 'detail.purchase'})).toHaveLength(1)
    })

    // New Test
    it('passes number of merchants to "new window" message', () => {
      expect(wrapper.find({id: 'detail.window'}).prop('values')).toMatchObject({
        numMerchants: 3,
      })
    })
  })
})
```

Running `yarn test` one final time in the terminal should result in passing tests.

### Resources üìñ

- [getChildContext() Deprecation - react-intl](https://formatjs.io/docs/react-intl/upgrade-guide-3x/#testing)
- [Testing - react-intl](https://formatjs.io/docs/react-intl/testing/)

## üì¶ Use Webpack to Conditionally Include an Intl Polyfill for Older Browsers

### Deprecation ‚ö†

The migration to using native Intl APIs in react-intl v3 may have rendered this lesson obsolete. In the [resources](#resources-) for these lesson notes, I've included a link to the react-intl v2 -> v3 upgrade guide and specifically the _Migrate to using native Intl APIs_ section.

Furthermore, `require.ensure()` is disabled as of Create React App 2.0. Conditionally loading polyfills is now going to require some implementation [like this](https://2ality.com/2017/01/import-operator.html#conditional-loading-of-modules).

The following notes will cover the video lesson content. If you have ideas about how to update the lesson code in order to implement the functionality described in this lesson on newer versions of react-intl and Create React App, please contribute to these notes!

### Adding Dependencies

In the terminal, we run

```bash
yarn add intl
```

### Conditionally Including Intl Polyfill

After the package is installed, we need to navigate to **src/index.js** and conditionally include it.

Here's what we want: If `window.Intl` doesn't exist, we are going to `ensure` that the `intl` polyfill, as well as all of our needed locale files, are in this project.

### index.js

```js
...
import App from './App';
import './index.css';

if (!window.Intl) {
  require.ensure([
    'intl',
    'intl/locale-data/jsonp/en.js',
    'intl/locale-data/jsonp/fr.js',
    'intl/locale-data/jsonp/es.js'
  ], (require) => {
    require('intl');
    require('intl/locale-data/jsonp/en.js');
    require('intl/locale-data/jsonp/fr.js');
    require('intl/locale-data/jsonp/es.js');
  })
}

...
```

Next, we're going to wrap our "business" logic in a function. In other words, we'll be moving all of the code that follows what we've just added into a `runApp()` function.

### index.js

```js
...
function runApp() {
  let locale = (navigator.languages && navigator.languages[0])
  || navigator.language
  || navigator.userLanguage
  || 'en-US';

  ReactDOM.render(
    <IntlProvider locale={locale} defaultLocale="en-US" messages={flattenMessages(messages[locale])}>
    <App />
    </IntlProvider>,
  document.getElementById('root')
  );
}
```

The reason for this is so that we don't penalize browsers that do understand `window.Intl` by adding all of the defined polyfills.

We will now need to instantiate `runApp()` after our `require.ensure()` method. Furthemore, we'll need to add an `else` statement containing only `runApp()` for browsers that support `window.Intl`.

### index.js

```js
if (!window.Intl) {
  require.ensure(
    [
      'intl',
      'intl/locale-data/jsonp/en.js',
      'intl/locale-data/jsonp/fr.js',
      'intl/locale-data/jsonp/es.js',
    ],
    (require) => {
      require('intl')
      require('intl/locale-data/jsonp/en.js')
      require('intl/locale-data/jsonp/fr.js')
      require('intl/locale-data/jsonp/es.js')
    },
  )
  runApp()
} else {
  runApp()
}
```

### Resources üìñ

- [Upgrade Guide v2 -> v3 - react-intl](https://formatjs.io/docs/react-intl/upgrade-guide-3x/)
- [Migrate to using native Intl APIs](https://formatjs.io/docs/react-intl/upgrade-guide-3x/#migrate-to-using-native-intl-apis)
- [Create React App 2.0 - Breaking Changes](https://reactjs.org/blog/2018/10/01/create-react-app-v2.html#breaking-changes)

import DefaultLayout from '../../../layouts/index'

export default DefaultLayout
